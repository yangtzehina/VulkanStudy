

## [Jitter Camera (Anti-Aliasing)](vkrt_tuto_jitter_cam.md.htm)

Anti-aliases the image by accumulating small variations of rays over time. 

* Random ray direction generation
* Read/write/accumulate final image

![Antialising](Images/antialiasing.png height= "300px")

## [Handle Thousands of Objects](vkrt_tuto_instances.md.htm)  

The current example allocates memory for each object, each of which has several buffers.
This shows how to get around Vulkan's limits on the total number of memory allocations by using a memory allocator.

* Extending the limit of 4096 memory allocations
* Using the Device Memory Allocator and Vulkan Memory Allocator

![20000 'unique' objects](Images/VkInstances.png height= "300px") 

## [Any Hit Shader (Transparency)](vkrt_tuto_anyhit.md.htm)

Implements transparent materials by adding a new shader to the Hit group and using the material
information to discard hits over time.

* Adding any hit (.ahit) to the ray tracing pipeline
* Making intersections randomly hit or not, which produces simple transparency

![One use of any hit shaders](Images/anyhit.png height= "300px") 


## [Reflections](vkrt_tuto_reflection.md.htm)

Reflections can be implemented by shooting new rays from the closest hit shader, or by iteratively shooting them from
the raygen shader. This example shows the limitations and differences of these implementations.

* Calling traceNV() from the closest hit shader (recursive)
* Adding more data to the ray payload to continue the ray from the raygen shader. 

![Hundreds of Reflections](Images/reflections.png height= "300px") 


## [Multiple Closest Hits Shader and Shader Records](vkrt_tuto_manyhits.md.htm)

Explains how to add more closest hit shaders, choose which instance uses which shader, and add data per SBT that can be
retrieved in the shader, and more.

* One closest hit shader per object
* Sharing closest hit shaders for some object
* Passing shader record to closest hit shader 

![Different Closest Hit and Shader Record](Images/manyhits.png height= "300px") 


## [Animation](vkrt_tuto_animation.md.htm)

This tutorial shows how animating the transformation matrices of the instances (TLAS) 
and animating the vertices of an object (BLAS) in a compute shader could be done.

* Refit of top level acceleration structure
* Refit of bottom level acceleration structure

![TLAS and BLAS Animation](Images/animation2.gif height= "300px") 


## [Intersection Shader](vkrt_tuto_intersection.md.html)

Adding thousands of implicit primitives and using an intersection shader to render spheres and cubes. The tutorial
explains what is needed to get procedural hit groups working.

* Intersection shader
* Sphere intersection
* Axis aligned bounding box intersection

![Intersection Shader with Spheres and Cubes](Images/ray_tracing_intersection.png height= "300px")



## [Callable Shader](vkrt_tuto_callable.md.html)

Replacing branching by callable shaders. The code to execute the lighting is done in separate callable shaders instead of being part of the main code.

* Adding multiple callable shaders
* Calling ExecuteCallableNV from  the closest hit shader

![Infinite | Spot | Point lights from callable shaders](Images/callable.png height= "300px")




<!-- Markdeep: -->
<link rel="stylesheet" href="vkrt_tutorial.css?">
<script> window.markdeepOptions = { tocStyle: "medium" };</script>
<script src="markdeep.min.js" charset="utf-8"></script>
<script src="https://casual-effects.com/markdeep/latest/markdeep.min.js" charset="utf-8"></script>
<script>
    window.alreadyProcessedMarkdeep || (document.body.style.visibility = "visible")
</script>
